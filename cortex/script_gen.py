"""
Generates standalone installation scripts for offline or automated deployments.
"""

import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import TypedDict

from rich.console import Console

console = Console()


class StackConfig(TypedDict):
    packages: list[dict | str]
    verification: str | None


STACK_DEPS: dict[str, StackConfig] = {
    "docker": {
        "packages": [
            {"name": "docker.io", "check_command": "docker"},
            {"name": "docker-compose", "check_command": "docker-compose"},
        ],
        "verification": "docker --version",
    },
    "python": {
        "packages": [
            {"name": "python3", "check_command": "python3"},
            {"name": "python3-venv", "check_command": "python3 -m venv --help"},
        ],
        "verification": "python3 --version",
    },
    "nodejs": {
        "packages": [
            {"name": "nodejs", "check_command": "node"},
            {"name": "npm", "check_command": "npm"},
        ],
        "verification": "node --version",
    },
    "ollama": {
        "packages": [
            {"name": "ollama", "check_command": "ollama"},
        ],
        "verification": "ollama --version",
    },
}


BASH_TEMPLATE = """#!/bin/bash
# Generated by Cortex Linux - {date}
# Stack: {stack}

set -euo pipefail

GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
RED='\\033[0;31m'
NC='\\033[0m'

log_info() {{ echo -e "${{GREEN}}âœ“${{NC}} $1"; }}
log_warn() {{ echo -e "${{YELLOW}}âš ${{NC}} $1"; }}
log_error() {{ echo -e "${{RED}}âœ—${{NC}} $1"; }}

command_exists() {{
    command -v "$1" >/dev/null 2>&1
}}

trap 'log_error "Failed at line $LINENO"' ERR

log_info "Installing {stack}..."

if ! sudo apt-get update >/dev/null 2>&1; then
    log_error "Failed to update package manager"
    exit 1
fi

{install_commands}

log_info "Verifying {stack}..."
if ! {verify_commands}; then
    log_error "Verification failed for {stack}"
    exit 1
fi
log_info "Complete!"
"""


class ScriptGenerator:
    """Build installation scripts for supported stacks."""

    def __init__(self) -> None:
        """
        Initialize the ScriptGenerator.

        Sets up the output directory at ~/cortex/install-scripts and prepares
        the history tracking file.
        """
        self.cortex_dir = Path.home() / "cortex" / "install-scripts"
        self.cortex_dir.mkdir(parents=True, exist_ok=True)
        self.history_file = self.cortex_dir / "script_history.yaml"

    def generate(
        self, filename: str, stack: str = "docker", format: str = "bash", dry_run: bool = False
    ) -> None:
        """
        Generate an installation script for the specified stack.
        Args:
            filename: Output script filename (absolute or relative to cortex_dir)
            stack: Stack to install (docker, python, nodejs, ollama)
            format: Output format (bash or ansible)
            dry_run: If True, print content without writing file
        Raises:
            SystemExit: If stack or format is invalid, or file write fails
        """
        if stack not in STACK_DEPS:
            console.print(f"[red]âœ— Unknown stack: {stack}[/red]")
            console.print(f"Available stacks: {', '.join(STACK_DEPS.keys())}")
            sys.exit(1)

        deps = STACK_DEPS[stack]

        if format == "bash":
            install_cmds: list[str] = []
            for pkg in deps.get("packages", []):
                if isinstance(pkg, dict):
                    pkg_name = pkg["name"]
                    check_command = pkg.get("check_command", pkg_name)
                else:
                    pkg_name = pkg
                    check_command = pkg

                install_cmds.append(
                    f"""if ! command_exists {check_command}; then
    log_info "Installing {pkg_name}..."
    sudo apt-get install -y {pkg_name} >/dev/null 2>&1
else
    log_warn "{pkg_name} already installed"
fi"""
                )

            verify_commands = deps.get("verification", "true")
            content = BASH_TEMPLATE.format(
                date=datetime.now().isoformat(),
                stack=stack,
                install_commands="\n".join(install_cmds),
                verify_commands=verify_commands,
            )

        elif format == "ansible":
            pkg_lines: list[str] = []
            for pkg in deps.get("packages", []):
                if isinstance(pkg, dict):
                    pkg_name = pkg.get("name")
                else:
                    pkg_name = pkg
                pkg_lines.append(f"      - {pkg_name}")
            pkg_list = "\n".join(pkg_lines)

            content = f"""---
# Generated by Cortex Linux - {datetime.now().isoformat()}
# Stack: {stack}
- name: Install {stack}
  hosts: localhost
  gather_facts: yes
  become: yes
  tasks:
    - name: Update apt cache
      apt:
        update_cache: yes
      when: ansible_os_family == "Debian"
    - name: Install packages
      apt:
        pkg:
{pkg_list}
        state: present
      when: ansible_os_family == "Debian"
    - name: Verify installation
      command: {deps.get("verification", "echo OK")}
      register: version_check
      changed_when: false
"""
        else:
            console.print(f"[red]âœ— Unknown format: {format}[/red]")
            sys.exit(1)

        if filename.startswith("/"):
            path = Path(filename)
        else:
            path = self.cortex_dir / filename

        if dry_run:
            console.print("[yellow]ðŸ“‹ DRY RUN - Script content:[/yellow]")
            console.print("[dim]" + content + "[/dim]")
            console.print(f"[yellow]Would write to: {path.absolute()}[/yellow]")
        else:
            try:
                path.parent.mkdir(parents=True, exist_ok=True)
                path.write_text(content)
                path.chmod(0o755)

                if not path.exists():
                    console.print(f"[red]âœ— Failed to write script to {path.absolute()}[/red]")
                    sys.exit(1)

                console.print("[green]âœ“ Generated installation script[/green]")
                console.print(f"[dim]Location: {path.absolute()}[/dim]")
                console.print(f"[dim]Run: bash {path.absolute()}[/dim]")

                self._save_to_history(stack, format, str(path.absolute()))
            except Exception as e:
                console.print(f"[red]âœ— Error writing script: {str(e)}[/red]")
                sys.exit(1)

    def test(self, filename: str, sandbox: bool = True) -> None:
        """
        Validate the syntax of a generated script.
        Args:
            filename: Script file to test (absolute or relative to cortex_dir)
            sandbox: If True, run bash -n syntax check; if False, skip validation
        Raises:
            SystemExit: If script not found or syntax check fails
        """
        if filename.startswith("/"):
            path = Path(filename)
        else:
            path = self.cortex_dir / filename

        if not path.exists():
            console.print(f"[red]âœ— Script not found: {filename}[/red]")
            console.print(f"[dim]Expected: {path.absolute()}[/dim]")
            sys.exit(1)

        console.print(f"[cyan]ðŸ§ª Testing script: {path.absolute()}[/cyan]")

        try:
            if sandbox:
                result = subprocess.run(
                    ["bash", "-n", str(path)], capture_output=True, text=True, timeout=10
                )
                if result.returncode != 0:
                    console.print("[red]âœ— Syntax error in script:[/red]")
                    console.print(f"[dim]{result.stderr}[/dim]")
                    sys.exit(1)

                console.print("[green]âœ“ Syntax check passed[/green]")
                console.print("[green]âœ“ Script is valid bash[/green]")
                console.print("[green]âœ“ Ready for execution[/green]")
            else:
                console.print("[green]âœ“ Syntax validation passed[/green]")

        except subprocess.TimeoutExpired:
            console.print("[red]âœ— Script test timed out[/red]")
            sys.exit(1)
        except Exception as e:
            console.print(f"[red]âœ— Test error: {str(e)}[/red]")
            sys.exit(1)

    def _save_to_history(self, stack: str, format: str, filename: str) -> None:
        """Save generation entry to history."""
        try:
            import yaml
        except ImportError:
            return

        entry = {
            "timestamp": datetime.now().isoformat(),
            "stack": stack,
            "format": format,
            "filename": filename,
        }

        history: list[dict] = []
        if self.history_file.exists():
            try:
                content = self.history_file.read_text()
                if content.strip():
                    history = yaml.safe_load(content) or []
            except Exception:
                history = []

        history.append(entry)
        self.history_file.write_text(yaml.safe_dump(history, sort_keys=False))

    def show_history(self, limit: int = 10) -> None:
        """
        Display recent script generation history.

        Args:
            limit: Maximum number of history entries to show (default: 10)
        """
        try:
            import yaml
        except ImportError:
            console.print("[yellow]âš  YAML not available, cannot show history[/yellow]")
            return

        if not self.history_file.exists():
            console.print("[yellow]âš  No script history found[/yellow]")
            return

        try:
            data = yaml.safe_load(self.history_file.read_text()) or []
        except Exception:
            console.print("[yellow]âš  Error reading history[/yellow]")
            return

        if not data:
            console.print("[yellow]âš  Script history is empty[/yellow]")
            return

        console.print("[bold]ðŸ“œ Script Generation History (latest first)[/bold]")
        console.print()

        for i, entry in enumerate(reversed(data[-limit:]), 1):
            timestamp = entry.get("timestamp", "?")
            stack = entry.get("stack", "?")
            fmt = entry.get("format", "?")
            filename = entry.get("filename", "?")

            console.print(f"{i}. [cyan]{stack}[/cyan] ({fmt}) â†’ {filename}")
            console.print(f"   [dim]{timestamp}[/dim]")
